{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hypermedia","text":"<p>A fully typed Python HTML Renderer with a focus on composability of elements. All html tags available with autocompletion for all the tags attributes. A perfect companion for htmx and ships with FastAPI integration.</p>"},{"location":"#showcase","title":"Showcase","text":"pythonindex(user=\"John Doe\").dump()partial().dump() views/index.py<pre><code>def base() -&gt; Element:  # (1)\n    \"\"\"Your base html document. Written once. Reused anywhere.\"\"\"\n    return Html(\n        Head(slot=\"head\"),\n        Body(\n            Header(slot=\"header\"),\n            Main(slot=\"content\"),\n            Footer(slot=\"footer\"),\n        ),\n    )\n\n\ndef user_header(user: str):\n    return Div(user, Button(\"log out\", hx_get=\"/logout\"))\n\n\ndef partial() -&gt; Element:\n    return Div(Header1(\"Welcome\"), Paragraph(\"Lorem ipsum...\"))\n\n\ndef full(user: str | None) -&gt; Element:\n    html = base()\n    # add title:\n    html.extend(\"head\", Title(\"Welcome to test.com\"))\n\n    # If user is logged in add user header\n    if user:\n        html.extend(\"header\", user_header(user))\n\n    # Extend with index content\n    html.extend(\n        \"content\",\n        partial(),\n    )\n\n    return html\n</code></pre> <ol> <li>This function is usually placed in <code>common.py</code> or similar since it will be used by all view files.\u00b4</li> </ol> <pre><code>&lt;html&gt;\n\n&lt;head&gt;\n    &lt;title&gt;Welcome to test.com&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;header&gt;\n        &lt;!-- (1) --&gt;\n        &lt;div&gt;John Doe&lt;button hx-get='/logout'&gt;log out&lt;/button&gt;&lt;/div&gt;\n    &lt;/header&gt;\n    &lt;main&gt;\n        &lt;!-- (2) --&gt;\n        &lt;div&gt;\n            &lt;h1&gt;Welcome&lt;/h1&gt;\n            &lt;p&gt;Lorem ipsum...&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;&lt;/footer&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre> <ol> <li>Base was extended with result from <code>user_header(user: str)</code> function because a user was logged in!</li> <li>This part is rendered by the <code>partial()</code> function.</li> </ol> <pre><code>&lt;div&gt;\n    &lt;h1&gt;Welcome&lt;/h1&gt;\n    &lt;p&gt;Lorem ipsum...&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"#why-use-hypermedia","title":"Why use Hypermedia","text":"<p>If the above example intrigues you then that should be more than enough to give <code>hypermedia</code> a go. </p> <p>Other reasons for hypermedia:</p> <ul> <li>You need to create html with Python</li> <li>You want to create html snippets and weave them together.</li> <li>You think __ HTMX__ makes a lot of sense.</li> <li>Html attributes? yes. Every html element have autocompletion for their specific attributes.</li> <li>Jinja? tired of not being able to use your types and models? hypermedia never leaves python land, so you keep it all!</li> <li>You want to make a website with FastAPI - <code>hypermedia</code> ships with special decorator for FastAPI</li> </ul>"},{"location":"#goal","title":"Goal","text":"<p>To make it easy to write html in python.</p>"},{"location":"#why","title":"Why","text":"<p>This was just the way we wanted to write html with python. We didn't want to have jinja files were we lost all typing and autocompletion from our python project. And we felt that existing solutions didn't do <code>composability</code> the way we wanted to do it. Especially with regards to working with <code>htmx</code> with partials and full pages.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributing section not written yet. but basically, add issues, ask good questions. Come with good suggestions &lt;3</p>"},{"location":"#installation","title":"Installation","text":"<p>Package is on pypi. Use <code>pip</code> or <code>poetry</code> to install</p> <p><pre><code>pip install hypermedia\n</code></pre> <pre><code>poetry add hypermedia\n</code></pre></p> <p>what to do next? head over to the quickstart or introduction sections!</p>"},{"location":"htmx/","title":"HTMX","text":""},{"location":"htmx/#the-concept","title":"The Concept","text":"<p>The core concept of HTMX is that the server responds with HTML, and that we can choose with a CSS selector which part of the page will be updated with the HTML response from the server.</p> <p>This means that we want to return snippets of HTML, or <code>partials</code>, as they are also called.</p>"},{"location":"htmx/#the-problem","title":"The Problem","text":"<p>The problem is that we need to differentiate if it's HTMX that called an endpoint for a <code>partial</code>, or if the user just navigated directly to it and needs the <code>whole page</code> back in the response.</p>"},{"location":"htmx/#the-solution","title":"The Solution","text":"<p>HTMX provides an <code>HX-Request</code> header that is always true. We can check for this header to know if it's an HTMX request or not.</p> <p>We've chosen to implement that check in a <code>@htmx</code> decorator. The decorator expects <code>partial</code> and optionally <code>full</code> arguments in the endpoint definition. These must be resolved by FastAPI's dependency injection system.</p> <p>These can be read about in the fastapi section.</p> <pre><code>from hypermedia.fastapi import htmx, full\n</code></pre> <p>The <code>partial</code> argument is a function that returns the partial HTML. The <code>full</code> argument is a function that needs to return the whole HTML, for example on first navigation or a refresh.</p> <p>Note: <code>partial</code> and <code>full</code> arguments needs to be wrapped in <code>Depends</code> so that the full function's dependencies are resolved! Hypermedia ships an extra <code>full</code> wrapper, which is basically just making the function lazily loaded. The <code>full</code> wrapper must be used, and the <code>@htmx</code> decorator will call the lazily wrapped function to get the full HTML page when needed.</p> <p>Note: The following code is in FastAPI, but could have been anything. As long as you check for HX-Request and return partial/full depending on if it exists or not.</p> <pre><code>def render_base():\n    \"\"\"Return base HTML, used by all full renderers.\"\"\"\n    return ElementList(Doctype(), Body(slot=\"body\"))\n\n\ndef render_fruits_partial():\n    \"\"\"Return partial HTML.\"\"\"\n    return Div(Ul(Li(\"Apple\"), Li(\"Banana\"), Button(\"reload\", hx_get=\"/fruits\")))\n\n\ndef render_fruits():\n    \"\"\"Return base HTML extended with `render_fruits_partial`.\"\"\"\n    return render_base().extend(\"body\", render_fruits_partial())\n\n\n@router.get(\"/fruits\", response_class=HTMLResponse)\n@htmx\nasync def fruits(\n    request: Request,\n    partial: Element = Depends(render_fruits_partial),\n    full: Element = Depends(full(render_fruits)),\n) -&gt; None:\n    \"\"\"Return the fruits page, partial or full.\"\"\"\n    pass\n</code></pre> <p>That's it. Now we have separated the rendering from the endpoint definition and handled returning partials and full pages when needed. Doing a full refresh will render the whole page. Clicking the button will make a htmx request and only return the partial.</p> <p>What is so cool about this is that it works so well with FastAPI's dependency injection.</p>"},{"location":"htmx/#really-making-use-of-dependency-injection","title":"Really making use of dependency injection","text":"<pre><code>fruits = {1: \"apple\", 2: \"orange\"}\n\ndef get_fruit(fruit_id: int = Path(...)) -&gt; str:\n    \"\"\"Get fruit ID from path and return the fruit.\"\"\"\n    return fruits[fruit_id]\n\ndef render_fruit_partial(\n    fruit: str = Depends(get_fruit),\n) -&gt; Element:\n    \"\"\"Return partial HTML.\"\"\"\n    return Div(fruit)\n\ndef render_fruit(\n    partial: Element = Depends(render_fruit_partial),\n):\n    return render_base().extend(\"content\", partial)\n\n@router.get(\"/fruits/{fruit_id}\", response_class=HTMLResponse)\n@htmx\nasync def fruit(\n    request: Request,\n    partial: Element = Depends(render_fruit_partial),\n    full: Element = Depends(full(render_fruit)),\n) -&gt; None:\n    \"\"\"Return the fruit page, partial or full.\"\"\"\n    pass\n</code></pre> <p>Here we do basically the same as the previous example, except that we make use of FastAPI's great dependency injection system. Notice the path of our endpoint has <code>fruit_id</code>. This is not used in the definition. However, if we look at our partial renderer, it depends on <code>get_fruit</code>, which is a function that uses FastAPI's <code>Path resolver</code>. The DI then resolves (basically calls) the fruit function, passes the result into our partial function, and we can use it as a value!</p> <p>This pattern with DI, Partials, and full renderers is what makes using FastAPI with HTMX worth it.</p> <p>In addition to this, one thing many are concerned about with HTMX is that since we serve HTML, there will be no way for another app/consumer to get a fruit in JSON. But the solution is simple:</p> <p>Because we already have a dependency that retrieves the fruit, we just need to add a new endpoint:</p> <pre><code>@router.get(\"/api/fruit/{fruit_id}\")\nasync def fruit(\n    request: Request,\n    fruit: str = Depends(get_fruit),\n) -&gt; str:\n    \"\"\"Return the fruit data.\"\"\"\n    return fruit\n</code></pre> <p>Notice we added <code>/api/</code> and just used DI to resolve the fruit and just returned it. Nice!</p>"},{"location":"fastapi/","title":"Hypermedia and FastAPI","text":"<p>Hypermedia can be used with any framework, but was created with FastAPI in mind and thus ships with some utility functions.</p> <p>In FastAPI you create function and decorate them to create routes. When FastAPI gets a request it looks for a function that is decorated with a path that matches the url. </p> <p>This section assumes you have read the html section of the documentation.</p>"},{"location":"fastapi/#returning-html-in-fastapi","title":"Returning html in FastAPI","text":"<pre><code>from fastapi import FastAPI\nfrom hypermedia import Div\n\napp = FastAPI()\n\n@app.get(\"\", response_class=HTMLResponse)\nasync def index(request: Request) -&gt; None:\n    \"\"\"Return an index page.\"\"\"\n    return Div(\"Hello world\").dump()\n</code></pre> <p>This is all you have to do. open <code>localhost:port</code> in your browser and you should get a page with the text <code>Hello world</code>.</p> <p>Notice the <code>.dump()</code></p> <p>with @htmx decorator</p> <pre><code>@app.get(\"\", response_class=HTMLResponse)\n@htmx\nasync def index(\n    request: Request,\n    partial: Element = Depends(render_simple_flows_index_partial),\n    full: Element = Depends(full(render_simple_flows_index)),\n) -&gt; None:\n    \"\"\"Return the list of transformers.\"\"\"\n    pass\n</code></pre> <pre><code>from hypermedia.fastapi import htmx, full\n</code></pre> <p>The <code>partial</code> argument is a function that returns the partial HTML. The <code>full</code> argument is a function that needs to return the whole HTML, for example on first navigation or a refresh.</p> <p>Note: <code>partial</code> and <code>full</code> arguments needs to be wrapped in <code>Depends</code> so that the full function's dependencies are resolved! Hypermedia ships an extra <code>full</code> wrapper, which is basically just making the function lazily loaded. The <code>full</code> wrapper must be used, and the <code>@htmx</code> decorator will call the lazily wrapped function to get the full HTML page when needed.</p> <p>Note: The following code is in FastAPI, but could have been anything. As long as you check for HX-Request and return partial/full depending on if it exists or not.</p> <pre><code>def render_base():\n    \"\"\"Return base HTML, used by all full renderers.\"\"\"\n    return ElementList(Doctype(), Body(slot=\"body\"))\n\n\ndef render_fruits_partial():\n    \"\"\"Return partial HTML.\"\"\"\n    return Div(Ul(Li(\"Apple\"), Li(\"Banana\"), Button(\"reload\", hx_get=\"/fruits\")))\n\n\ndef render_fruits():\n    \"\"\"Return base HTML extended with `render_fruits_partial`.\"\"\"\n    return render_base().extend(\"body\", render_fruits_partial())\n\n\n@router.get(\"/fruits\", response_class=HTMLResponse)\n@htmx\nasync def fruits(\n    request: Request,\n    partial: Element = Depends(render_fruits_partial),\n    full: Element = Depends(full(render_fruits)),\n) -&gt; None:\n    \"\"\"Return the fruits page, partial or full.\"\"\"\n    pass\n</code></pre> <p>That's it. Now we have separated the rendering from the endpoint definition and handled returning partials and full pages when needed. Doing a full refresh will render the whole page. Clicking the button will make a htmx request and only return the partial.</p> <p>What is so cool about this is that it works so well with FastAPI's dependency injection.</p>"},{"location":"fastapi/#really-making-use-of-dependency-injection","title":"Really making use of dependency injection","text":"<pre><code>fruits = {1: \"apple\", 2: \"orange\"}\n\ndef get_fruit(fruit_id: int = Path(...)) -&gt; str:\n    \"\"\"Get fruit ID from path and return the fruit.\"\"\"\n    return fruits[fruit_id]\n\ndef render_fruit_partial(\n    fruit: str = Depends(get_fruit),\n) -&gt; Element:\n    \"\"\"Return partial HTML.\"\"\"\n    return Div(fruit)\n\ndef render_fruit(\n    partial: Element = Depends(render_fruit_partial),\n):\n    return render_base().extend(\"content\", partial)\n\n@router.get(\"/fruits/{fruit_id}\", response_class=HTMLResponse)\n@htmx\nasync def fruit(\n    request: Request,\n    partial: Element = Depends(render_fruit_partial),\n    full: Element = Depends(full(render_fruit)),\n) -&gt; None:\n    \"\"\"Return the fruit page, partial or full.\"\"\"\n    pass\n</code></pre> <p>Here we do basically the same as the previous example, except that we make use of FastAPI's great dependency injection system. Notice the path of our endpoint has <code>fruit_id</code>. This is not used in the definition. However, if we look at our partial renderer, it depends on <code>get_fruit</code>, which is a function that uses FastAPI's <code>Path resolver</code>. The DI then resolves (basically calls) the fruit function, passes the result into our partial function, and we can use it as a value!</p> <p>This pattern with DI, Partials, and full renderers is what makes using FastAPI with HTMX worth it.</p> <p>In addition to this, one thing many are concerned about with HTMX is that since we serve HTML, there will be no way for another app/consumer to get a fruit in JSON. But the solution is simple:</p> <p>Because we already have a dependency that retrieves the fruit, we just need to add a new endpoint:</p> <pre><code>@router.get(\"/api/fruit/{fruit_id}\")\nasync def fruit(\n    request: Request,\n    fruit: str = Depends(get_fruit),\n) -&gt; str:\n    \"\"\"Return the fruit data.\"\"\"\n    return fruit\n</code></pre> <p>Notice we added <code>/api/</code> and just used DI to resolve the fruit and just returned it. Nice!</p>"}]}